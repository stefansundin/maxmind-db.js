{"version":3,"file":"MaxMindDB.min.js","mappings":"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","sources":["webpack://MaxMindDB/./src/MaxMindDB.ts"],"sourcesContent":["// https://maxmind.github.io/MaxMind-DB/\n\nexport default class MaxMindDB {\n  private buffer: undefined | ArrayBuffer;\n  private search_tree_size: undefined | number;\n  private data_section_start: undefined | number;\n  private ipv4_start: undefined | number;\n  private _metadata: undefined | object;\n\n  async load(data: ArrayBuffer | Blob | File | Response): Promise<void> {\n    if (data instanceof ArrayBuffer) {\n      this.buffer = data;\n    } else {\n      this.buffer = await data.arrayBuffer();\n    }\n    this.search_tree_size = undefined;\n    this.data_section_start = undefined;\n    this.ipv4_start = undefined;\n    this._metadata = undefined;\n  }\n\n  get metadata(): any {\n    if (this._metadata !== null) {\n      return this._metadata;\n    }\n    if (!this.buffer) {\n      throw new Error('Database not loaded');\n    }\n\n    const header = this.string2Uint8Array('\\xab\\xcd\\xefMaxMind.com');\n    let position;\n    for (\n      position = this.buffer.byteLength - header.length - 1;\n      position > this.buffer.byteLength - 300;\n      position--\n    ) {\n      if (\n        this.equal(\n          new Uint8Array(this.buffer.slice(position, position + header.length)),\n          header,\n        )\n      ) {\n        break;\n      }\n    }\n    if (position === this.buffer.byteLength - 300) {\n      throw new Error('Metadata section not found');\n    }\n\n    const metadata_start = position + header.length;\n    const [, , map] = this.decode(metadata_start);\n    this._metadata = map;\n\n    this.search_tree_size = ((map.record_size * 2) / 8) * map.node_count;\n    this.data_section_start = this.search_tree_size + 16;\n\n    return this._metadata;\n  }\n\n  get(ip: string): Array<any> {\n    const addr = this.packIP(ip);\n    const [r] = this.record(addr);\n    return r;\n  }\n\n  record(addr: ArrayBuffer): Array<any> {\n    const [pointer, depth] = this.find_address_in_tree(addr);\n    if (pointer === 0) {\n      return [null, depth];\n    }\n\n    return [this.resolve_data_pointer(pointer), depth];\n  }\n\n  resolve_data_pointer(pointer: number): Array<any> {\n    if (!this.buffer) {\n      throw new Error('Database not loaded');\n    }\n\n    const offset_in_file =\n      pointer - this.metadata.node_count + this.search_tree_size!;\n\n    if (offset_in_file >= this.buffer.byteLength) {\n      throw new Error('The search tree is corrupt');\n    }\n\n    return this.decode(offset_in_file);\n  }\n\n  find_address_in_tree(addr: ArrayBuffer): Array<number> {\n    const bit_count = 8 * addr.byteLength;\n    const node_count = this.metadata.node_count;\n    const view = new DataView(addr);\n\n    let node = this.start_node(bit_count);\n    let depth = 0;\n    while (true) {\n      if (depth >= bit_count || node >= node_count) {\n        break;\n      }\n      const c = view.getUint8(depth >>> 3);\n      const bit = 1 & (c >>> (7 - (depth % 8)));\n      node = this.read_node(node, bit);\n      depth++;\n    }\n\n    if (node === node_count) {\n      return [0, depth];\n    } else if (node > node_count) {\n      return [node, depth];\n    }\n\n    throw new Error('Invalid node in search tree');\n  }\n\n  start_node(addr_length: number): number {\n    if (addr_length === 128) {\n      return 0;\n    } else if (this.ipv4_start) {\n      return this.ipv4_start;\n    }\n\n    let node = 0;\n    if (this.metadata.ip_version === 6) {\n      for (let i = 0; i < 96; i++) {\n        if (node >= this.metadata.node_count) {\n          break;\n        }\n        node = this.read_node(node, 0);\n      }\n    }\n\n    this.ipv4_start = node;\n    return this.ipv4_start;\n  }\n\n  read_node(node_number: number, index: number): number {\n    if (!this.buffer) {\n      throw new Error('Database not loaded');\n    }\n\n    const node_byte_size = this.metadata.record_size / 4;\n    const base_offset = node_number * node_byte_size;\n    const record_size = this.metadata.record_size;\n    const view = new DataView(this.buffer);\n\n    if (record_size === 24) {\n      const offset = index === 0 ? base_offset : base_offset + 3;\n      const bytes = new Uint8Array(4);\n      bytes[0] = 0;\n      bytes[1] = view.getUint8(offset);\n      bytes[2] = view.getUint8(offset + 1);\n      bytes[3] = view.getUint8(offset + 2);\n      const view2 = new DataView(bytes.buffer);\n      return view2.getUint32(0, false);\n    } else if (record_size === 28) {\n      if (index === 0) {\n        const n = view.getUint32(base_offset);\n        const last24 = n >>> 8;\n        const first4 = (n & 0xf0) << 20;\n        return first4 | last24;\n      }\n      const n = view.getUint32(base_offset + 3);\n      return n & 0x0fffffff;\n    } else if (record_size === 32) {\n      const offset = index === 0 ? base_offset : base_offset + 4;\n      const n = view.getUint32(offset);\n      return n;\n    }\n\n    throw new Error(`Unsupported record size: ${record_size}`);\n  }\n\n  decode(position: number): Array<any> {\n    if (!this.buffer) {\n      throw new Error('Database not loaded');\n    }\n\n    const view = new DataView(this.buffer);\n    let ctrl_byte = view.getUint8(position);\n    position += 1;\n    let type = ctrl_byte >>> 5;\n    let size = ctrl_byte & 0x1f;\n\n    if (type === 0) {\n      // extended type\n      ctrl_byte = view.getUint8(position);\n      position += 1;\n      type = ctrl_byte + 7;\n    }\n\n    if (type === 1) {\n      // pointer\n      const ptr_size = (ctrl_byte >>> 3) & 0x03;\n      const ptr_value = ctrl_byte & 0x07;\n      let value = this.data_section_start!;\n      if (ptr_size === 0) {\n        // If the size is 0, the pointer is built by appending the next byte to the last three bits to produce an 11-bit value.\n        const bytes = new Uint8Array(2);\n        bytes.set([ptr_value, view.getUint8(position)]);\n        const view2 = new DataView(bytes.buffer);\n        value += view2.getUint16(0, false);\n      } else if (ptr_size === 1) {\n        // If the size is 1, the pointer is built by appending the next two bytes to the last three bits to produce a 19-bit value + 2048.\n        const bytes = new Uint8Array(4);\n        bytes.set([\n          0,\n          ptr_value,\n          view.getUint8(position),\n          view.getUint8(position + 1),\n        ]);\n        const view2 = new DataView(bytes.buffer);\n        value += view2.getUint32(0, false) + 2048;\n      } else if (ptr_size === 2) {\n        // If the size is 2, the pointer is built by appending the next three bytes to the last three bits to produce a 27-bit value + 526336.\n        const bytes = new Uint8Array(4);\n        bytes[0] = ptr_value;\n        bytes[1] = view.getUint8(position);\n        bytes[2] = view.getUint8(position + 1);\n        bytes[3] = view.getUint8(position + 2);\n        const view2 = new DataView(bytes.buffer);\n        value += view2.getUint32(0, false) + 526336;\n      } else if (ptr_size === 3) {\n        // Finally, if the size is 3, the pointerâ€™s value is contained in the next four bytes as a 32-bit value. In this case, the last three bits of the control byte are ignored.\n        value += view.getUint32(position);\n      }\n\n      [, , value] = this.decode(value);\n      return [type, position + ptr_size + 1, value];\n    }\n\n    if (size === 29) {\n      // If the value is 29, then the size is 29 + the next byte after the type specifying bytes as an unsigned integer.\n      size = 29 + view.getUint8(position);\n      position += 1;\n    } else if (size === 30) {\n      // If the value is 30, then the size is 285 + the next two bytes after the type specifying bytes as a single unsigned integer.\n      size = 285 + view.getUint16(position);\n      position += 2;\n    } else if (size === 31) {\n      // If the value is 31, then the size is 65,821 + the next three bytes after the type specifying bytes as a single unsigned integer.\n      const bytes = new Uint8Array(4);\n      bytes.set([\n        0,\n        view.getUint8(position),\n        view.getUint8(position + 1),\n        view.getUint8(position + 2),\n      ]);\n      const view2 = new DataView(bytes.buffer);\n      size = 65821 + view2.getUint32(0, false);\n      position += 3;\n    }\n\n    if (type === 2) {\n      // UTF-8 string\n      const value = new TextDecoder('utf-8').decode(\n        new Uint8Array(this.buffer.slice(position, position + size)),\n      );\n      return [type, position + size, value];\n    } else if (type === 3) {\n      // double\n      if (size !== 8) {\n        throw new Error('Unsupported size of double');\n      }\n      const value = view.getFloat64(position, false);\n      return [type, position + 8, value];\n    } else if (type === 5) {\n      // unsigned 16-bit int\n      let value: number;\n      if (size === 0) {\n        value = 0;\n      } else if (size === 1) {\n        const bytes = new Uint8Array(2);\n        bytes[1] = view.getUint8(position);\n        const view2 = new DataView(bytes.buffer);\n        value = view2.getUint16(0, false);\n      } else if (size === 2) {\n        value = view.getUint16(position, false);\n      } else {\n        throw new Error(`Unexpected size: ${size}`);\n      }\n      return [type, position + size, value];\n    } else if (type === 6) {\n      // unsigned 32-bit int\n      let value: number;\n      if (size === 0) {\n        value = 0;\n      } else if (size === 4) {\n        value = view.getUint32(position, false);\n      } else if (size > 4) {\n        throw new Error(`Unexpected size: ${size}`);\n      } else {\n        const bytes = new Uint8Array(4);\n        for (let i = 0; i < size; i++) {\n          bytes[4 - size + i] = view.getUint8(position + i);\n        }\n        const view2 = new DataView(bytes.buffer);\n        value = view2.getUint32(0, false);\n      }\n      return [type, position + size, value];\n    } else if (type === 7) {\n      // 111 - map\n      const map: any = {};\n      for (let i = 0; i < size; i++) {\n        let key_type, key, value_type, value;\n        [key_type, position, key] = this.decode(position);\n        [value_type, position, value] = this.decode(position);\n        map[key] = value;\n      }\n      return [type, position, map];\n    } else if (type === 9) {\n      // unsigned 64-bit int\n      let value: number | bigint;\n      if (size === 0) {\n        value = 0;\n      } else if (size === 8) {\n        value = view.getBigUint64(position, false);\n      } else if (size > 8) {\n        throw new Error(`Unexpected size: ${size}`);\n      } else {\n        const bytes = new Uint8Array(8);\n        for (let i = 0; i < size; i++) {\n          bytes[8 - size + i] = view.getUint8(position + i);\n        }\n        const view2 = new DataView(bytes.buffer);\n        value = view2.getBigUint64(0, false);\n      }\n      if (value <= Number.MAX_SAFE_INTEGER) {\n        value = Number(value);\n      }\n      return [type, position + size, value];\n    } else if (type === 11) {\n      // array\n      const array: Array<any> = [];\n      for (let i = 0; i < size; i++) {\n        let value_type, value;\n        [value_type, position, value] = this.decode(position);\n        array.push(value);\n      }\n      return [type, position, array];\n    } else if (type === 14) {\n      // boolean\n      const value: boolean = size === 1;\n      return [type, position, value];\n    } else {\n      throw new Error(`Unknown type: ${type}`);\n    }\n  }\n\n  equal(a: Uint8Array, b: Uint8Array): boolean {\n    if (a.byteLength !== b.byteLength) {\n      return false;\n    }\n    for (let i = 0; i < a.byteLength; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  packIP(ip: string): ArrayBuffer {\n    if (ip.includes('.')) {\n      // IPv4\n      const segments = ip.split('.');\n      if (segments.length !== 4) {\n        throw new Error('Invalid IP');\n      }\n      const bytes = new Uint8Array(4);\n      for (let i = 0; i < 4; i++) {\n        const n = parseInt(segments[i], 10);\n        if (n < 0 || n > 255 || isNaN(n) || n.toString() !== segments[i]) {\n          throw new Error('Invalid IP');\n        }\n        bytes[i] = n;\n      }\n      return bytes.buffer;\n    } else {\n      // IPv6\n      const segments = ip.split(':');\n      if (segments.length > 8) {\n        throw new Error('Invalid IP');\n      }\n      const bytes = new Uint8Array(16);\n      for (let i = 0, j = 0; i < segments.length; i++, j++) {\n        if (segments[i].length > 4) {\n          throw new Error('Invalid IP');\n        }\n        if (segments[i] === '') {\n          if (i === 0 || i === segments.length - 1) {\n            continue;\n          }\n          j += 8 - segments.length;\n          if (j > 8) {\n            throw new Error('Invalid IP');\n          }\n          continue;\n        }\n        const n = parseInt(segments[i], 16);\n        if (n < 0 || n > 65535 || isNaN(n)) {\n          throw new Error('Invalid IP');\n        }\n        const hextet = new Uint16Array(1);\n        hextet[0] = n;\n        const view = new DataView(hextet.buffer);\n        bytes[2 * j] = view.getUint8(1);\n        bytes[2 * j + 1] = view.getUint8(0);\n      }\n      return bytes.buffer;\n    }\n  }\n\n  private string2Uint8Array(s: string): Uint8Array {\n    const arr = new Uint8Array(s.length);\n    for (let i = 0; i < s.length; i++) {\n      arr[i] = s.charCodeAt(i);\n    }\n    return arr;\n  }\n}\n"],"names":["async","data","ArrayBuffer","this","buffer","arrayBuffer","search_tree_size","undefined","data_section_start","ipv4_start","_metadata","metadata","Error","header","string2Uint8Array","position","byteLength","length","equal","Uint8Array","slice","metadata_start","map","decode","record_size","node_count","get","ip","addr","packIP","r","record","pointer","depth","find_address_in_tree","resolve_data_pointer","offset_in_file","bit_count","view","DataView","node","start_node","bit","getUint8","read_node","addr_length","ip_version","i","node_number","index","base_offset","offset","bytes","getUint32","n","ctrl_byte","type","size","ptr_size","ptr_value","value","set","getUint16","TextDecoder","getFloat64","key_type","key","value_type","getBigUint64","Number","MAX_SAFE_INTEGER","array","push","a","b","includes","segments","split","parseInt","isNaN","toString","j","hextet","Uint16Array","s","arr","charCodeAt"],"sourceRoot":""}